/*!
 * Copyright 2014 Digital Services, University of Cambridge Licensed
 * under the Educational Community License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var util = require('util');
var ShortId = require('shortid');

var AuthzUtil = require('oae-authz/lib/util');
var ContentDAO = require('oae-content/lib/internal/dao');
var Locking = require('oae-util/lib/locking');
var log = require('oae-logger').logger('oae-tickets');
var PublicationsAPI = require('oae-publications');
var Validator = require('oae-util/lib/validator').Validator;

var TicketsConstants = require('./constants').TicketsConstants;
var TicketsDAO = require('./internal/dao');
var TicketsEmitter = require('./internal/emitter');
var TicketsValidator = require('./validator').Validator;

/**
 * Register a decorator that adds the ticket information to the publication profile
 */
PublicationsAPI.registerPublicationsDecorator('ticket', function(ctx, publications, callback) {
    return _addTicketsToPublications(ctx, publications, callback);
});

/**
 * Create a new ticket
 *
 * @param  {Object}         ctx                 The current context
 * @param  {String}         contentId           The id of the content item that will be linked to the publication
 * @param  {String[]}       sourceIds           The source Id's of the publication
 * @param  {Publication}    publication         Object representing a publication
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        Error object containing error code and error message
 * @param  {Ticket}         callback.ticket     Object representing the created ticket
 */
var createTicket = module.exports.createTicket = function(ctx, contentId, sourceIds, publication, callback) {

    // Validate the 'contentId' and 'sourceIds'
    var validator = new Validator();
    validator.check(contentId, {'code': 400, 'msg': 'A content id must be provided'}).isResourceId();
    validator.check(sourceIds, {'code': 400, 'msg': 'Missing or invalid sourceIds'}).notEmpty();
    if (validator.hasErrors()) {
        log().error({'code': validator.getFirstError().code, 'err': validator.getFirstError().msg, 'contentId': contentId}, 'Error while creating new ticket');
        return callback(validator.getFirstError());
    }

    // Store the tenant alias
    var tenantAlias = ctx.tenant().alias;

    // Check if the content item exists
    ContentDAO.Content.getContent(contentId, function(err, content) {
        if (err) {
            log().error({'code': err.code, 'msg': err.msg, 'contentId': contentId}, 'The content item could not be found');
            return callback({'code': err.code, 'msg': err.msg});
        }

        // Check if the current user is allowed to create tickets
        if (!_canCreateTicket(ctx, content)) {
            return callback({'code': 401, 'msg': 'Only authorized users are allowed to create tickets'});
        }

        // Validate the 'publication'
        validator.check(null, {'code': 400, 'msg': 'Missing or invalid publication'}).isObject(publication);
        if (publication) {
            validator.check(publication.displayName, {'code': 400, 'msg': 'Missing or invalid displayName'}).isShortString();
            validator.check(publication.authors, {'code': 400, 'msg': 'Missing authors'}).notEmpty();
            validator.check(null, {'code': 400, 'msg': 'Missing authors'}).isArray(publication.authors);
            validator.check(publication.journalName, {'code': 400, 'msg': 'Missing or invalid journalName'}).isShortString();
            validator.check(publication.publisher, {'code': 400, 'msg': 'Missing or invalid publisher'}).isShortString();
            validator.check(publication.date, {'code': 400, 'msg': 'Missing or invalid date'}).isNumeric();
            validator.check(publication.contactEmail, {'code': 400, 'msg': 'Missing or invalid contactEmail'}).isEmail();
            validator.check(publication.publicationType, {'code': 400, 'msg': 'Missing or invalid publicationType'}).isShortString();
            validator.check(publication.useCambridgeAddendum, {'code': 400, 'msg': 'Missing or invalid useCambridgeAddendum'}).isShortString();
            validator.check(null, {'code': 400, 'msg': 'Missing or invalid underEmbargo'}).isBoolean(publication.underEmbargo);

            if (publication.institution) {
                validator.check(publication.institution, {'code': 400, 'msg': 'Invalid institution'}).isShortString();
            }

            if (publication.department) {
                validator.check(publication.department, {'code': 400, 'msg': 'Invalid department'}).isShortString();
            }

            if (publication.acceptanceDate !== null) {
                validator.check(publication.acceptanceDate, {'code': 400, 'msg': 'Invalid acceptanceDate'}).isNumeric();
            }

            if (publication.embargoDate !== null) {
                validator.check(publication.embargoDate, {'code': 400, 'msg': 'Invalid embargoDate'}).isNumeric();
            }
        }

        if (validator.hasErrors()) {
            log().error({'code': validator.getFirstError().code, 'err': validator.getFirstError().msg, 'contentId': contentId}, 'Error while creating new ticket');
            return callback(validator.getFirstError());
        }

        // Keep track of the attempts to create a ticket
        var createTicketAttempts = 0;

        // Key that is used to lock the current cycle
        var key = util.format('oae-tickets:counter:%s', tenantAlias);

        /*!
         * To prevent a duplication of ticket ID's we need to lock the current ticket ID untill the ticket has been created
         */
        var _createTicket = function() {

            /*!
             * Release the lock on the `counter` key
             *
             * @param  {String}     lockToken       The lock token
             * @param  {Object}     [err]           The thrown error, if any
             * @param  {Ticket}     [ticket]        The generated ticket, if no error occurred
             * @api private
             */
            var _releaseLocking = function(lockToken, err, ticket) {
                createTicketAttempts = 0;
                Locking.release(key, lockToken, function(lockErr) {
                    err = err || lockErr;
                    if (err) {
                        return callback(err);
                    }

                    TicketsEmitter.emit(TicketsConstants.events.CREATED_TICKET, ctx, ticket);
                    return callback(null, ticket);
                });
            };

            // Lock the key
            Locking.acquire(key, 15, function(err, lockToken) {
                createTicketAttempts++;
                if (err || !lockToken) {
                    if (createTicketAttempts < 10) {
                        return _createTicket();
                    }

                    log().error({'code': 400, 'msg': util.format('Unable to create ticket for content: "%s"', contentId)});
                    return callback({'code': 400, 'msg': 'Unable to create ticket for content'});
                }

                // Increase the current counter value
                TicketsDAO.increaseTicketsCounter(tenantAlias, function(err, counterValue) {
                    if (err) {
                        log().error({'err': err},'Error while creating ticket ID');
                        return _releaseLocking(lockToken, err);
                    }

                    var ticketId = _generateTicketId(tenantAlias);
                    var externalId = 'OA-' + counterValue;
                    var createdBy = ctx.user().id;

                    // Create a publication
                    PublicationsAPI.createPublication(tenantAlias, sourceIds, publication, function(err, publication) {
                        if (err) {
                            log().error({'err': err}, 'An error occurred while creating a publication');
                            return callback(err);
                        }

                        // Create the ticket
                        TicketsDAO.createTicket(ticketId, externalId, publication.id, tenantAlias, createdBy, function(err, ticket) {
                            if (err) {
                                log().error({'code': err.code, 'msg': err.msg, 'ticketId': ticketId}, 'Error while creating a ticket');
                                return _releaseLocking(lockToken, err);
                            }

                            // Add the publication to the ticket
                            ticket.publication = publication;

                            // Release the key
                            return _releaseLocking(lockToken, null, ticket);
                        });
                    });
                });
            });
        };

        _createTicket();
    });
};

/**
 * Deletes a specific ticket
 *
 * @param  {Object}     ctx                 The current context
 * @param  {String}     ticketId            The id of the ticket that needs to be deleted
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Error object containing error code and error message
 * @param  {Ticket}     callback.ticket     Object representing the deleted ticket
 */
var deleteTicket = module.exports.deleteTicket = function(ctx, ticketId, callback) {
    var validator = new Validator();
    validator.check(ticketId, {'code': 400, 'msg': 'No ticket ID specified'}).notEmpty();
    validator.check(ticketId, {'code': 400, 'msg': 'invalid ticket ID specified'}).isShortString();
    validator.check(ticketId, {'code': 400, 'msg': 'A valid ticket ID must be provided'}).isTicketId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if the ticket exists
    TicketsDAO.getTicket(ticketId, function(err, ticket) {
        if (err) {
            return callback(err);
        }

        if (!_canManageTicket(ctx, ticket)) {
            return callback({'code': 401, 'msg': 'Only authorized users are allowed to delete tickets'});
        }

        // Delete the ticket
        TicketsDAO.deleteTicket(ticketId, ticket.publicationId, function(err) {
            if (err) {
                return callback(err);
            }

            TicketsEmitter.emit(TicketsConstants.events.DELETED_TICKET, ticket);
            return callback(null, ticket);
        });
    });
};

/**
 * Returns a specific ticket
 *
 * @param  {Object}     ctx                 The current context
 * @param  {String}     ticketId            The id of the ticket that needs to be returned
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Error object containing error code and error message
 * @param  {Ticket}     callback.ticket     Object representing the requested ticket
 */
var getTicket = module.exports.getTicket = function(ctx, ticketId, callback) {
    var validator = new TicketsValidator();
    validator.check(ticketId, {'code': 400, 'msg': 'No ticket ID specified'}).notEmpty();
    validator.check(ticketId, {'code': 400, 'msg': 'invalid ticket ID specified'}).isShortString();
    validator.check(ticketId, {'code': 400, 'msg': 'A valid ticket ID must be provided'}).isTicketId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Request the ticket
    TicketsDAO.getTicket(ticketId, function(err, ticket) {
        if (err) {
            return callback(err);
        }

        if (!_canRequestTicket(ctx, ticket)) {
            return callback({'code': 401, 'msg': 'Only authorized users are allowed to request tickets'});
        }

        return callback(null, ticket);
    });
};

/**
 * Returns a collection of tickets, specified by their ID's
 *
 * @param  {Object}     ctx                 The current context
 * @param  {String[]}   ticketIds           Collection of ticket ID's
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Error object containing error code and error message
 * @param  {Ticket[]}   callback.tickets    Array containing a ticket object for each available ticket for the user
 */
var getTickets = module.exports.getTickets = function(ctx, ticketIds, callback) {
    if (!_.isArray(ticketIds)) {
        ticketIds = [ ticketIds ];
    }

    // Validate the provided parameters
    var validator = new Validator();
    validator.check(ticketIds, {'code': 400, 'msg': 'No ticket ID\'s specified'}).notEmpty();
    if (ticketIds) {
        validator.check(ticketIds.length, {'code': 400, 'msg': 'Invalid number of ticket ID\'s specified'}).min(1);
        _.each(ticketIds, function(ticketId) {
            validator.check(ticketId, {'code': 400, 'msg': 'Invalid ticket ID specified'}).isTicketId();
        });
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Return a collection of tickets
    return TicketsDAO.getTickets(ticketIds, function(err, tickets) {
        if (err) {
            log().error({'err': err}, 'Error while requesting tickets');
            return callback(err);
        }

        // TODO: check if the user is allowed to request the tickets

        // Return the tickets
        return callback(null, tickets);
    });
};

/**
 * Updates a ticket
 *
 * @param  {Context}    ctx                 The current context
 * @param  {String}     ticketId            The id of the ticket that needs to be updated
 * @param  {Object}     opts                Object containing the updates for the ticket
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Error object containing error code and error message
 * @param  {Ticket}     callback.ticket     Object representing the updated ticket
 */
var updateTicket = module.exports.updateTicket = function(ctx, ticketId, opts, callback) {

    // Validate the ticketId
    var validator = new TicketsValidator();
    validator.check(ticketId, {'code': 400, 'msg': 'No ticket ID specified'}).notEmpty();
    validator.check(ticketId, {'code': 400, 'msg': 'invalid ticket ID specified'}).isShortString();
    validator.check(ticketId, {'code': 400, 'msg': 'A valid ticket ID must be provided'}).isTicketId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if the ticket exists
    TicketsDAO.getTicket(ticketId, function(err, ticket) {
        if (err) {
            log().error({'code': err.code, 'msg': err.msg, 'ticketId': ticketId}, 'Error while updating ticket');
            return callback(err);
        }

        if (!_canManageTicket(ctx, ticket)) {
            return callback({'code': 401, 'msg': 'Only authorized users are allowed to update tickets'});
        }

        // Validate the opts
        validator = new Validator();
        validator.check(null, {'code': 400, 'msg': 'Missing or invalid update parameters'}).isObject(opts);
        validator.check(_.keys(opts).length, {'code': 400, 'msg': 'Missing or invalid update parameters'}).min(1);
        if (validator.hasErrors()) {
            return callback(validator.getFirstError());
        }

        // Update the ticket
        TicketsDAO.updateTicket(ticketId, opts, function(err) {
            if (err) {
                log().error({'code': err.code, 'msg': err.msg, 'ticket': ticket, 'opts': opts}, 'Error while updating ticket');
                return callback(err);
            }

            // Return the updated ticket
            ticket = _.extend(ticket, opts);
            return callback(null, ticket);
        });
    });
};

//////////////////////////
//  INTERNAL FUNCTIONS  //
//////////////////////////

/**
 * Add the corresponding ticket to a publication
 *
 * @param  {Context}            ctx                         The current context
 * @param  {Publication[]}      publications                A collection of publications that need to be decorated
 * @param  {Function}           callback                    Standard callback function
 * @param  {Object}             callback.err                Error object containing the error code and error message
 * @param  {Publication[]}      callback.publications       A collection of decorated publications
 * @api private
 */
var _addTicketsToPublications = function(ctx, publications, callback) {

    // Filter the publication ID's from the collection
    var publicationIds = _.pluck(publications, 'id');

    // Request the tickets corresponding to the publication ID's
    TicketsDAO.getTicketsByPublicationIds(publicationIds, function(err, tickets) {
        if (err && err.code !== 404) {
            log().error({'code': err.code, 'msg': err.msg}, 'Error while requesting tickets by publication ID\'s');
            return callback(err);
        }

        // Decorate each publication with its corresponding ticket
        _.each(publications, function(publication) {
            if (_canRequestTicket(ctx, publication)) {
                publication.ticket = _.find(tickets, function(ticket) { return ticket.publicationId === publication.id; });
            }
        });

        // Return the decorated publications
        return callback(null, publications);
    });
};

/**
 * Verifies that the current user is allowed to create a new ticket
 *
 * @param  {Object}     ctx         The current context
 * @param  {Content}    content     The content item where a ticket needs to be created for
 * @return {Boolean}                Whether the current user is allowed to create a ticket or not
 * @api private
 */
var _canCreateTicket = function(ctx, content) {
    if (!ctx.user()) {
        return false;
    }

    // Global admins and admins where the publication was created in are always allowed to create tickets
    if (ctx.user().isGlobalAdmin() || ctx.user().isAdmin(content.tenant.alias)) {
        return true;
    }

    // Only the creator of the content item should be allowed to create a ticket
    if (ctx.user().id === content.createdBy) {
        return true;
    }

    return false;
};

/**
 * Verifies that the current user is allowed to manage the ticket
 *
 * @param  {Object}     ctx         The current context
 * @param  {Ticket}     ticket      The ticket item that needs to be managed
 * @return {Boolean}                Whether the current user is allowed to manage a ticket or not
 * @api private
 */
var _canManageTicket = function(ctx, ticket) {
    if (!ctx.user()) {
        return false;
    }

    // Global admins and admins where the publication was created in are always allowed to manage tickets
    if (ctx.user().isGlobalAdmin() || ctx.user().isAdmin(ticket.tenantAlias)) {
        return true;
    }

    return false;
};

/**
 * Verifies that the current is allowed to request the ticket
 *
 * @param  {Object}     ctx         The current context
 * @param  {Ticket}     ticket      The ticket item that needs to be managed
 * @return {Boolean}                Whether the current user is allowed to manage a ticket or not
 * @api private
 */
var _canRequestTicket = function(ctx, ticket) {
    if (!ctx.user()) {
        return false;
    }

    // Global admins and admins where the publication was created in are always allowed to manage tickets
    if (ctx.user().isGlobalAdmin() || ctx.user().isAdmin(ticket.tenantAlias)) {
        return true;
    }

    // The creator of the ticket is allowed to manage the ticket
    if (ctx.user().id === ticket.createdBy) {
        return true;
    }

    return false;
};

/**
 * Generates a new ticket ID.
 *
 * @param  {String}     tenantAlias     The tenant alias for the ticket
 * @return {String}                     The new ticket ID
 * @api private
 */
var _generateTicketId = function(tenantAlias) {
    return AuthzUtil.toId('t', tenantAlias, ShortId.generate());
};

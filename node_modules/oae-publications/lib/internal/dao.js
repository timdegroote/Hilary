/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var ShortId = require('shortid');

var AuthzUtil = require('oae-authz/lib/util');
var Cassandra = require('oae-util/lib/cassandra');
var log = require('oae-logger').logger('oae-activity');
var PrincipalsDAO = require('oae-principals/lib/internal/dao');

var Publication = require('oae-publications/lib/model').Publication;

/**
 * Creates a publication record by:
 *  - storing its metadata
 *  - storing its source Ids
 *  - storing its authors
 *
 * @param  {String}         tenantAlias             The tenant alias
 * @param  {Publication}    publication             The publication to store
 * @param  {String[]}       sourceIds               An array of source IDs
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Standard error object (if any)
 * @param  {Publication}    callback.publication    The updated publication
 */
var createPublication = module.exports.createPublication = function(tenantAlias, publication, sourceIds, callback) {

    var publicationId = _generatePublicationId(tenantAlias);
    var queries = [];

    // Create the publication row
    var publicationRowValues = _publicationToRow(publication);
    queries.push(Cassandra.constructUpsertCQL('Publications', 'publicationId', publicationId, publicationRowValues));

    // If there is a user ID in the set of provided authors, add this publication to their library
    var userIds = _.filter(publication.authors, AuthzUtil.isUserId);
    if (userIds.length) {
        _generatePublicationsByUserQueries(queries, publicationId, publication.date, userIds);
    }

    // Keep track of who created the publication object in a separate column family. This will only be executed when not using Symplectic since we don't have an acting user
    if (publication.createdBy) {

        // Add the current timestamp in the column name, so that when we retrieve all publications created by a user they will be sorted by when they were created
        var publicationHash = Date.now() + '#' + publicationId;
        queries.push({'query': 'INSERT INTO "PublicationsByCreator" ("userId", "publicationId", "value") VALUES (?, ?, ?)', 'parameters': [publication.createdBy, publicationHash, '1']});
    }

    // Add all the sources where this publication was found in
    _.each(sourceIds, function(sourceId) {
        queries.push(Cassandra.constructUpsertCQL('PublicationsBySource', 'sourceId', sourceId, {'publicationId': publicationId}));
    });

    Cassandra.runBatchQuery(queries, function(err) {
        if (err) {
            return callback(err);
        }

        _detectPrincipalsInUserArray(publication.authors, function(err, authors) {
            if (err) {
                return callback(err);
            }

            _insertAuthorsForPublication(publicationId, authors, function(err) {
                if (err) {
                    return callback(err);
                }

                _insertFundersForPublication(publicationId, publication.funders, function(err) {
                    if (err) {
                        return callback(err);
                    }

                    publication.id = publicationId;
                    return callback(null, publication);
                });
            });
        });
    });
};

/**
 * Detects OAE principals in an array of User IDs and will fetch the displayname for each one found.
 *
 * @param  {String[]}   plainUserIds        Collection of user IDs
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        Standard error object (if any)
 * @return {Object[]}   callback.users      An array containing objects ({'displayName': '', 'id': ''}) with the displayName and id found for each item in the supplied array
 * @api private
 */
var _detectPrincipalsInUserArray = function(plainUserIds, callback) {
    if (!plainUserIds) {
        return callback(null);
    }

    var OAEUserIds = _.filter(plainUserIds, AuthzUtil.isUserId);
    var users = _.map(_.difference(plainUserIds, OAEUserIds), function(plainUserId) {
        return {
            'id': plainUserId,
            'displayName': plainUserId
        };
    });

    // Return prematurely if no OAE user ids were found
    if (!OAEUserIds.length) {
        return callback(null, users);
    }

    PrincipalsDAO.getPrincipals(OAEUserIds, null, function(err, principals) {
        if (err) {
            return callback(err);
        }

        _.each(principals, function(principal) {
            users.push({
                'id': principal.id,
                'displayName': principal.displayName
            });
        });

        return callback(null, users);
    });
};


/**
 * Get a publication by its ID
 *
 * @param  {String}         publicationId           The ID of the publication to retrieve
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Standard error object, if any
 * @param  {Publication}    callback.publication    The publication matching the `publicationId`
 */
var getPublication = module.exports.getPublication = function(publicationId, callback) {
    Cassandra.runQuery('SELECT * FROM "Publications" WHERE "publicationId" = ?', [publicationId], function(err, publicationRows) {
        if (err) {
            return callback(err);
        }

        if (_.isEmpty(publicationRows)) {
            return callback({'code': 404, 'msg': 'The publication could not be found'}, null);
        }

        var publication = _rowToPublication(publicationRows[0]);
        _getAuthorsForPublications([publication], function(err, publications) {
            if (err) {
                return callback(err);
            }

            // Fetch the funders for the publication
            _getFundersForPublications(publications, function(err, publications) {
                if (err) {
                    return callback(err);
                }

                // Return the publication
                return callback(null, publications[0]);
            });
        });
    });
};

/**
 * Gets a set of publications for a given userId
 *
 * @param  {String}         userId                  The ID of the user of which the publications he is linked with should be returned
 * @param  {String}         start                   The publication ordering token from which to start fetching publications (see `nextToken` in callback params)
 * @param  {Number}         limit                   The number of publications that should be returned
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Standard error object, if any
 * @param  {Publication[]}  callback.publications   An array of publication objects
 * @param  {String}         callback.nextToken      The value to provide in the `start` parameter to get the next set of results
 */
var getPublicationsForUser = module.exports.getPublicationsForUser = function(userId, start, limit, callback) {

    // Publications are typically ingested on an interval, so we can relax the consistency requirement
    Cassandra.runPagedQuery('PublicationsByUser', 'userId', userId, 'publicationId', start, limit, {'reversed': true, 'consistency': 'QUORUM'}, function(err, rows, nextToken) {
        if (err) {
            return callback(err);
        }

        if (rows.length === 0) {
            return callback(null, [], null);
        }

        // Get the actual publications
        var publicationsIds = [];
        _.each(rows, function(row) {
            var publicationId = row.get('publicationId').value.split('#').slice(1).join('#');
            publicationsIds.push(publicationId);
        });

        Cassandra.runQuery('SELECT * FROM "Publications" WHERE "publicationId" IN (?)', [publicationsIds], function(err, publicationRows) {
            if (err) {
                return callback(err);
            }

            var publications = [];
            _.each(publicationRows, function(publicationRow) {
                publications.push(_rowToPublication(publicationRow));
            });

            // Fetch the authors for the publications
            _getAuthorsForPublications(publications, function(err, publications) {
                if (err) {
                    return callback(err);
                }

                // Fetch the funders for the publications
                _getFundersForPublications(publications, function(err, publications) {
                    if (err) {
                        return callback(err);
                    }

                    // Return the requested publications
                    return callback(null, publications, nextToken);
                });
            });
        });
    });
};

/**
 * Gets a set of publications for a user who created the publication
 *
 * @param  {String}         userId                  The ID of the user of which the publications he created should be returned
 * @param  {String}         start                   The publication ordering token from which to start fetching publications (see `nextToken` in callback params)
 * @param  {Number}         limit                   The number of publications that should be returned
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Standard error object, if any
 * @param  {Publication[]}  callback.publications   An array of publication objects
 * @param  {String}         callback.nextToken      The value to provide in the `start` parameter to get the next set of results
 */
var getPublicationsByCreator = module.exports.getPublicationsByCreator = function(userId, start, limit, callback) {

    // Publications are typically ingested on an interval, so we can relax the consistency requirement
    Cassandra.runPagedQuery('PublicationsByCreator', 'userId', userId, 'publicationId', start, limit, {'reversed': true}, function(err, rows, nextToken) {
        if (err) {
            return callback(err);
        }

        if (rows.length === 0) {
            return callback(null, [], null);
        }

        // Get the actual publications
        var publicationsIds = [];
        rows.forEach(function(row) {
            var publicationId = row.get('publicationId').value.split('#').slice(1).join('#');
            publicationsIds.push(publicationId);
        });

        Cassandra.runQuery('SELECT * FROM "Publications" WHERE "publicationId" IN (?)', [publicationsIds], function(err, publicationRows) {
            if (err) {
                return callback(err);
            }

            var publications = [];

            _.each(publicationRows, function(publicationRow) {
                publications.push(_rowToPublication(publicationRow));
            });

            // Fetch the authors for the publications
            _getAuthorsForPublications(publications, function(err, publications) {
                if (err) {
                    return callback(err);
                }

                // Fetch the funders for the publications
                _getFundersForPublications(publications, function(err, publications) {
                    if (err) {
                        return callback(err);
                    }

                    // Return the requested publications
                    return callback(null, publications, nextToken);
                });
            });
        });
    });
};

/**
 * Get all the publications that match a set of source identifiers
 *
 * @param  {String[]}   sourceIds               A set of source IDs
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            Standard error object, if any
 * @param  {Object}     callback.publications   A hash of publications that are keyed by the source ID
 */
var getPublicationsBySourceIds = module.exports.getPublicationsBySourceIds = function(sourceIds, callback) {
    if (_.isEmpty(sourceIds)) {
        return callback(null, {});
    }

    Cassandra.runQuery('SELECT * FROM "PublicationsBySource" WHERE "sourceId" IN (?)', [sourceIds], function(err, sourceRows) {
        if (err) {
            return callback(err);
        }

        var publicationsBySource = {};
        _.each(sourceRows, function(sourceRow) {
            if (sourceRow.get('publicationId')) {
                var sourceId = sourceRow.get('sourceId').value;
                var publicationId = sourceRow.get('publicationId').value;
                publicationsBySource[sourceId] = publicationId;
            }
        });

        var publicationIds = _.chain(publicationsBySource).values().uniq().value();
        if (publicationIds.length === 0) {
            return callback(null, {});
        }

        Cassandra.runQuery('SELECT * FROM "Publications" WHERE "publicationId" IN (?)', [publicationIds], function(err, publicationRows) {
            if (err) {
                return callback(err);
            }

            var publications = {};
            _.each(publicationRows, function(publicationRow) {
                var publication = _rowToPublication(publicationRow);
                publications[publication.id] = publication;
            });

            _.each(publicationsBySource, function(publicationId, sourceId) {
                publicationsBySource[sourceId] = publications[publicationId];
            });

            var allPublications = _.values(publications);

            // Fetch the authors for the publications
            _getAuthorsForPublications(allPublications, function(err, allPublications) {
                if (err) {
                    return callback(err);
                }

                // Fetch the funders for the publications
                _getFundersForPublications(allPublications, function(err, allPublications) {
                    if (err) {
                        return callback(err);
                    }

                    return callback(null, publicationsBySource);
                });
            });
        });
    });
};

/**
 * Links a publications to an OAE user. If an authorName is provided, the OAE user will replace that author
 *
 * @param  {Publication}    publication     The publication for which to link a user
 * @param  {String}         authorName      The name of the author that resembles this user. This plain-text name will be removed from the set and the userId will be injected
 * @param  {String}         userId          The ID of the user that will be linked
 * @param  {Function}       callback        Standard callback function
 * @param  {Object}         callback.err    Standard error object, if any
 */
var linkPublicationToUser = module.exports.linkPublicationToUser = function(publication, authorName, userId, callback) {
    var queries = [];

    // Generate a query that links the publication to the user
    _generatePublicationsByUserQueries(queries, publication.id, publication.date, [userId]);

    // Delete the plain-text author if one was provided
    if (authorName) {
        queries.push({'query': 'DELETE FROM "PublicationsAuthors" WHERE "publicationId" = ? AND "author" = ?', 'parameters': [publication.id, authorName]});
    }

    // Add the userId to the CF that maps a publication ID to a set of authors (that are known in OAE)
    queries.push({'query': 'INSERT INTO "PublicationsAuthors" ("publicationId", "author", "value") VALUES (?, ?, ?)', 'parameters': [publication.id, userId, authorName]});
    Cassandra.runBatchQuery(queries, callback);
};

/**
 * Updates the metadata for an existing publication and adds the provided sources.
 * This method will *NOT* add new or edit existing authors.
 *
 * @param  {Publication}    newPublication          The publication object that might contain updated information
 * @param  {Publication}    oldPublication          The old publication object
 * @param  {String[]}       sourceIds               An array of source IDs
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Standard error object (if any)
 * @param  {Publication}    callback.publication    The updated publication
 */
var setSourceIds = module.exports.setSourceIds = function(newPublication, oldPublication, sourceIds, callback) {

    var queries = [];

    // 1. Update the record
    newPublication = _.extend({}, oldPublication, newPublication);
    delete newPublication.id;
    var publicationRowValues = _publicationToRow(newPublication);
    queries.push(Cassandra.constructUpsertCQL('Publications', 'publicationId', oldPublication.id, publicationRowValues));

    // 2. Add all the sources where this publication was found in
    _.each(sourceIds, function(sourceId) {
        queries.push(Cassandra.constructUpsertCQL('PublicationsBySource', 'sourceId', sourceId, {'publicationId': oldPublication.id}));
    });

    // Note: We're *NOT* adding authors on update as different sources have different ways of writing author names
    // ex: Some sources would write `Simon Gaeremynck` as `Gaeremynck S`, others would simply write `Gaeremynck`, etc.

    // Send the queries off to cassandra
    Cassandra.runBatchQuery(queries, function(err) {
        if (err) {
            return callback(err);
        }

        newPublication.id = oldPublication.id;
        return callback(null, newPublication);
    });
};

/**
 * Updates the metadata for an existing publication
 *
 * @param  {String}         publicationID           The ID of the publication that needs to be updated
 * @param  {Object}         fields                  Object containing the updated values for the publication
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Standard error object (if any)
 * @param  {Publication}    callback.publication    The updated publication
 */
var updatePublication = module.exports.updatePublication = function(publicationId, fields, callback) {

    _detectPrincipalsInUserArray(fields.authors, function(err, authorRows) {
        if (err) {
            return callback(err);
        }

        _updateAuthorsForPublication(publicationId, authorRows, function(err) {
            if (err) {
                return callback(err);
            }

            _updateFundersForPublication(publicationId, fields.funders, function(err) {
                if (err) {
                    return callback(err);
                }

                // Don't update send the authors and funders as these are not stored on the Publication
                var publicationFields = _.omit(fields, 'authors', 'funders');
                if (_.isEmpty(publicationFields)) {
                    return getPublication(publicationId, callback);
                }

                // Construct the query to update the publication metadata
                var q = Cassandra.constructUpsertCQL('Publications', 'publicationId', publicationId, publicationFields, 'QUORUM');
                if (!q) {
                    return callback({'code': 500, 'msg': 'Unable to store publication fields'});
                }

                Cassandra.runQuery(q.query, q.parameters, function(err) {
                    return err ? callback(err) : getPublication(publicationId, callback);
                });
            });
        });
    });
};

/**
 * Update the authors for a specific publication
 *
 * @param  {String}         publicationId           The ID of the publication that needs the authors to be updated
 * @param  {Array}          authors                 The authors that need to be saved for the selected publication
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Standard error object, if any
 * @api private
 */
var _updateAuthorsForPublication = function(publicationId, authors, callback) {
    if (!authors) {
        return callback(null);
    }

    _clearAuthorsForPublication(publicationId, function(err) {
        if (err) {
            return callback(err);
        }

        _insertAuthorsForPublication(publicationId, authors, function(err) {
            return err ? callback(err) : callback(null);
        });
    });

    return callback(null)
};

/**
 * Remove all authors for a specific publication
 *
 * @param  {String}         publicationId           The ID of the publication the authors need to be cleared for
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Standard error object, if any
 * @api private
 */
var _clearAuthorsForPublication = function(publicationId, callback) {
    Cassandra.runQuery('DELETE FROM "PublicationsAuthors" WHERE "publicationId" = ?', [publicationId], function(err) {
        return err ? callback(err) : callback(null);
    });
};

/**
 * Insert authors for a specific publication
 *
 * @param  {String}         publicationId           The ID of the publication the authors need to be stored against
 * @param  {Array}          authors                 The authors that need to be stored against the publication
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Standard error object, if any
 * @api private
 */
var _insertAuthorsForPublication = function(publicationId, authors, callback) {
    var queries = _.map(authors, function(author) {
        return {'query': 'INSERT INTO "PublicationsAuthors" ("publicationId", "author", "value") VALUES (?, ?, ?)', 'parameters': [publicationId, author.id, author.displayName]};
    });

    Cassandra.runBatchQuery(queries, function(err) {
        return err ? callback(err) : callback(null);
    });
};

/**
 * Update the funders for a specific publication
 *
 * @param  {String}         publicationId           The ID of the publication that needs the funders to be updated
 * @param  {Array}          funders                 The funders that need to be saved for the selected publication
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Standard error object, if any
 * @api private
 */
var _updateFundersForPublication = function(publicationId, funders, callback) {
    if (!funders) {
        return callback(null);
    }

    _clearFundersForPublication(publicationId, function(err) {
        if (err) {
            return callback(err);
        }

        _insertFundersForPublication(publicationId, funders, function(err) {
            return err ? callback(err) : callback(null);
        });
    });
};

/**
 * Insert funders for a specific publication
 *
 * @param  {String}         publicationId           The ID of the publication the funders need to be stored against
 * @param  {Array}          funders                 The funders that need to be stored against the publication
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Standard error object, if any
 * @api private
 */
var _insertFundersForPublication = function(publicationId, funders, callback) {
    var queries = [];
    _.each(funders, function(funder) {
        queries.push({'query': 'INSERT INTO "PublicationsFunders" ("publicationId", "funder") VALUES(?, ?)', 'parameters': [publicationId, funder]});
    });

    Cassandra.runBatchQuery(queries, function(err) {
        return err ? callback(err) : callback(null);
    });
};

/**
 * Remove all funders for a specific publication
 *
 * @param  {String}         publicationId           The ID of the publication the funders need to be cleared for
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Standard error object, if any
 * @api private
 */
var _clearFundersForPublication = function(publicationId, callback) {
    Cassandra.runQuery('DELETE FROM "PublicationsFunders" WHERE "publicationId" = ?', [publicationId], function(err) {
        return err ? callback(err) : callback(null);
    });
};

/**
 * Generates a collection of queries that link a publication to each user
 *
 * @param  {String[]}      queries          A collection of queries
 * @param  {String}        publicationId    The ID of the publication that needs to be linked to a user
 * @param  {String}        publicationDate  The date when the publication was published
 * @param  {String[]}      userIDs          A collection of userIds
 */
var _generatePublicationsByUserQueries = function(queries, publicationId, publicationDate, userIds) {

    // If we're dealing with a date that is pre 2001-09-11 it will contain only 12 digits (rather than 13)
    // Because we rely on Cassandra's column ordering, we will need 13 digits here
    var colName = _formatNumber(publicationDate) + '#' + publicationId;

    // Generate a query for each user
    _.each(userIds, function(userId) {
        queries.push({'query': 'INSERT INTO "PublicationsByUser" ("userId", "publicationId", "value") VALUES (?, ?, ?)', 'parameters': [userId, colName, '1']});
    });
};

/**
 * Gets the authors for a set of publications and adds them in the `authors` array on each publication object
 *
 * @param  {Publication[]}      publications                A set of publication objects for which the authors should be retrieved
 * @param  {Function}           callback                    Standard callback function
 * @param  {Object}             callback.err                Standard error object, if any
 * @param  {Publication[]}      callback.publications       The publication objects with an `authors` array on each one of them
 * @api private
 */
var _getAuthorsForPublications = function(publications, callback) {
    var publicationsIds = _.map(publications, function(publication) { return publication.id; });

    // Get the authors for each publication
    Cassandra.runQuery('SELECT * FROM "PublicationsAuthors" WHERE "publicationId" IN (?)', [publicationsIds], function(err, authorRows) {
        if (err) {
            return callback(err);
        }

        _.each(authorRows, function(authorRow) {
            var publication = _.find(publications, function(publication) { return publication.id === authorRow.get('publicationId').value; });
            publication.authors = publication.authors || [];
            publication.authors.push(authorRow.get('author').value);
        });

        return callback(null, publications);
    });
};

/**
 * Gets the funders for a set of publications and adds then in the `funders` array on each publication object
 * @param  {Publication[]}      publications                A set of publication objects for which the funders should be retrieved
 * @param  {Function}           callback                    Standard callback function
 * @param  {Object}             callback.err                Standard error object, if any
 * @param  {Publication[]}      callback.publications       The publication objects with an `funders` array on each one of them
 * @api private
 */
var _getFundersForPublications = function(publications, callback) {

    // Gets the funders for each publication
    var publicationsIds = _.map(publications, function(publication) { return publication.id; });
    Cassandra.runQuery('SELECT * FROM "PublicationsFunders" WHERE "publicationId" IN (?)', [publicationsIds], function(err, rows) {
        if (err) {
            return callback(err);
        }

        _.each(rows, function(row) {
            var hash = Cassandra.rowToHash(row);
            var publication = _.find(publications, function(publication) { return publication.id === hash.publicationId; });
            publication.funders = publication.funders || [];
            publication.funders.push(hash.funder);
        });

        return callback(null, publications);
    });
};

////////////////////////
// INTERNAL FUNCTIONS //
////////////////////////

/**
 * Returns a formatted number so that it always returns 13 digits. A leading 0 will be prepended if necessary.
 *
 * @param  {Number}     nr  The number to format
 * @return {String}         The stringified representation of the passed in number but formatted with 13 digits
 * @api private
 */
var _formatNumber = function(nr) {
    if (nr.toString().length === 12) {
        return '0' + nr;
    } else {
        return nr;
    }
};

/**
 * Generates and returns a publication ID.
 * Publication IDs are not your typical OAE resource identifier as they are not really tied
 * to a particular tenant.
 *
 * @return {String}     The generated publication ID
 * @api private
 */
var _generatePublicationId = function(tenantAlias) {
    return 'p:' + tenantAlias + ':' + ShortId.generate();
};

/**
 * Converts a Cassandra row to a publication object
 *
 * @param  {Row}            row     The cassandra row to convert
 * @return {Publication}            The publication object
 * @api private
 */
var _rowToPublication = function(row) {
    var hash = Cassandra.rowToHash(row);
    return new Publication(hash.publicationId, hash.tenantAlias, hash.createdBy, hash.linkedContentId, hash.displayName, hash.publicationType, hash.date, hash.thumbnailUri, [], hash.publisher, hash);
};

/**
 * Converts a publication object to a plain hash that can be stored in the cassandra Publications CF
 *
 * @param  {Publication}    publication     The publication that will be stored
 * @return {Object}                         The object that can be stored
 * @api private
 */
var _publicationToRow = function(publication) {
    var rowValues = _.extend({}, publication);
    delete rowValues.profilePath;
    delete rowValues.authors;
    delete rowValues.funders;

    rowValues.date = parseInt(publication.date, 10);
    if (publication.acceptanceDate) {
        rowValues.acceptanceDate = parseInt(publication.acceptanceDate, 10);
    }
    return rowValues;
};

/*!
 * Copyright 2014 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('underscore');
var log = require('oae-logger').logger('oae-publications');
var Validator = require('oae-util/lib/validator').Validator;

var AuthenticationAPI = require('oae-authentication');
var AuthenticationDAO = require('oae-authentication/lib/internal/dao');
var AuthzUtil = require('oae-authz/lib/util');
var ContentAPI = require('oae-content');
var ContentDAO = require('oae-content/lib/internal/dao').Content;
var ContentUtil = require('oae-content/lib/internal/util');
var OaeUtil = require('oae-util/lib/util');
var TenantsAPI = require('oae-tenants');
var PrincipalsUtil = require('oae-principals/lib/util');

var PublicationsConstants = require('./constants').PublicationsConstants;
var PublicationsDAO = require('./internal/dao');
var PublicationsEmitter = require('./internal/emitter');
var PublicationsUtil = require('./util');
var PublicationsValidator = require('./validator').Validator;

var publicationsProfileDecorators = {};

////////////////////////
//  PUBLIC FUNCTIONS  //
////////////////////////

/**
 * Register a decorator for the full publication profile.
 * In this case, the requested publication needs to be decorated with its linked ticket.
 *
 *  * When the `oae-tickets` module is initialized, a listener is registered in this (`oae-publications`) module:
 *  *
 *  * publicationsProfileDecorators = {
 *  *     'ticket': [Function]
 *  * };
 *  *
 *  * After the publication has been retrieved, all the decorators need to be executed. These are stored temporary untill the publication is returned:
 *  *
 *  * _.each(publicationsProfileDecorators, function(listener, namespace) {
 *  *     listener(ctx, publicationId, function(err, decorator) {
 *  *         decorators[namespace] = decorator;
 *  *         ...
 *  *     });
 *  * });
 *  *
 *  * When all the decorators have been executed, we return the created, decorated publication:
 *  *
 *  * return callback(null, _.extend(publication, decorators);
 *
 * @param  {String}         namespace                   The unique namespace for this decorator
 * @param  {Function}       decorator                   The function that will provide additional data for the publication profile
 * @param  {Context}        decorator.ctx               The context of the current request
 * @param  {Publication[]}  decorator.publications      The publications being decorated
 * @param  {Function}       decorator.callback          This function should be invoked with the decoration object when complete
 * @param  {Object}         decorator.callback.err      An error that occurred during decoration, if any
 * @param  {Object}         decorator.callback.data     The decoration data to bind to the publication profile
 */
var registerPublicationsDecorator = module.exports.registerPublicationsDecorator = function(namespace, decorator) {
    if (publicationsProfileDecorators[namespace]) {
        throw new Error(util.format('Attempted to register duplicate publication profile decorator with namespace "%s"', namespace));
    } else if (!_.isFunction(decorator)) {
        throw new Error(util.format('Attempted to register publication profile decorator for namespace "%s" without a decorator function', namespace));
    }

    publicationsProfileDecorators[namespace] = decorator;
};

/**
 * Exposes the ingester API with which ingesters can ingest and/or link publication.
 * The exposed functions on this object will bypass any security checks, so please ensure careful usage.
 */
var IngesterAPI = module.exports.IngesterAPI = {};

/**
 * Ingests a publication without performing any access checks.
 * This method is only intended to be used by Publication ingesters. Any other codepaths should use the `createPublication` method.
 *
 * @param  {String}         tenantAlias             The tenant alias
 * @param  {Publication}    publication             The publication to ingest
 * @param  {String[]}       sourceIds               An array of source identifiers
 * @param  {Function}       callback                Standard callback method
 * @param  {Object}         callback.err            Standard error object
 * @param  {Object}         callback.publication    The ingested publication
 * @param  {String}         callback.result         The result of the ingestion process. This will be one of `PublicationsConstants.ingestionResult` and will indicate whether the publication has been created, updated or ignored
 */
IngesterAPI.ingestPublication = function(tenantAlias, publication, sourceIds, callback) {
    var validator = new Validator();

    // Verify the sources
    validator.check(sourceIds, {'code': 400, 'msg': 'Missing source IDs'}).isArray(sourceIds);
    if (_.isArray(sourceIds)) {
        validator.check(sourceIds.length, {'code': 400, 'msg': 'At least one source ID should be provided'}).min(1);

        _.each(sourceIds, function(sourceId) {
            validator.check(sourceId, {'code': 400, 'msg': 'Empty source IDs are not allowed`'}).notEmpty();
            validator.check(sourceId, {'code': 400, 'msg': 'A source ID should hold the form `<source name>#<id at source>`'}).contains('#');
        });
    }

    // Verify the publication object
    validator.check(null, {'code': 400, 'msg': 'Missing publication'}).isObject(publication);
    if (_.isObject(publication)) {

        // Check the required parameters
        var parameters = ['displayName', 'publicationType', 'date', 'authors'];
        _.each(parameters, function(parameter) {
            validator.check(publication[parameter], {'code': 400, 'msg': 'Missing ' + parameter}).notEmpty();
        });
        validator.check(publication.publicationType, {'code': 400, 'msg': 'Unknown publication type'}).isIn(_.values(PublicationsConstants.publicationTypes));
        validator.check(publication.date, {'code': 400, 'msg': 'The publication date is malformed'}).isInt();

        // Check that at least one author has been provided
        validator.check(null, {'code': 400, 'msg': 'Authors should be provided as an array'}).isArray(publication.authors);
        if (publication.authors) {
            validator.check(publication.authors.length, {'code': 400, 'msg': 'At least one author should be provided'}).min(1);
        }

        // Ensure that the acceptanceDate is a number if it's present
        if (publication.acceptanceDate) {
            validator.check(publication.acceptanceDate, {'code': 400, 'msg': 'The publication acceptanceDate is malformed'}).isNumeric();
        }
    }

    if (validator.hasErrors()) {
        log().error({'err': validator.getFirstError(), 'publication': publication, 'sourceIds': sourceIds}, 'Ingest publication validation error');
        return callback(validator.getFirstError());
    }

    // Check if a publication with this source ID already exists
    PublicationsDAO.getPublicationsBySourceIds(sourceIds, function(err, publicationsBySource) {
        if (err) {
            return callback(err);
        }

        // Get the uniq publications
        var publicationsById = {};
        _.each(publicationsBySource, function(publication) {
            publicationsById[publication.id] = publication;
        });
        var publications = _.values(publicationsById);

        // If nothing was found we're dealing with a publication that we've not seen before previously
        if (publications.length === 0) {
            PublicationsDAO.createPublication(tenantAlias, publication, sourceIds, function(err, createdPublication) {
                if (err) {
                    return callback(err);
                }
                return callback(null, createdPublication, PublicationsConstants.ingestionResult.CREATED);
            });

        // If we got a hit, we already ingested this publication (possible with another source ID though)
        // We try to update it and add our sources
        } else if (publications.length === 1) {
            PublicationsDAO.setSourceIds(publication, publications[0], sourceIds, function(err, updatedPublication) {
                if (err) {
                    return callback(err);
                }
                return callback(null, updatedPublication, PublicationsConstants.ingestionResult.UPDATED);
            });

        /*
         * This situation can occur when 2 harvesters ingested publications from different sources previously.
         * For example:
         *     - Harvester 1 ingests a publication harvested from arxiv
         *     - Harvester 2 ingests a publication harvested from pubmed
         *     - Harvester 3 (this one) ingests a publication that it knew was available on arxiv and pubmed (and possibly others)
         *
         * This is obviously a bit annoying. Especially if both publications are linked to different content items.
         * TODO: Check if they are linked to a piece of content.
         * If none of them are, or, if only one of them is, we can probably do a merge.
         * If more than 1 is linked, we have a problem.
         */
        } else if (publications.length > 1) {
            log().warn({'publication': publication, 'existingPublications': publications}, 'Found duplicate publications that could not be resolved automatically');
            return callback(null, publication, PublicationsConstants.ingestionResult.IGNORED);
        }
    });
};

/**
 * Links an OAE user to a publication. The authorname that is used in the set should be provided.
 * This does not necessarily have to be an exact match as some disambiguiation will be attempted.
 *
 * @param  {String}     publicationId   The publication to link the user to
 * @param  {String}     authorName      The name of the user as its stored in the external system/on the publication
 * @param  {String}     userId          The OAE user ID to link
 * @param  {Function}   callback        Standard callback function
 */
IngesterAPI.linkPublicationToUser = function(publicationId, authorName, userId, callback) {
    var validator = new Validator();
    _validatePublicationId(validator, publicationId);
    validator.check(authorName, {'code': 400, 'msg': 'Missing author name'}).notEmpty();
    validator.check(userId, {'code': 400, 'msg': 'Missing or invalid userId'}).isUserId();
    if (validator.hasErrors()) {
        log().error({'err': validator.getFirstError()}, 'Link publication to user validation error');
        return callback(validator.getFirstError());
    }

    PublicationsDAO.getPublication(publicationId, function(err, publication) {
        if (err) {
            return callback(err);
        }

        return _linkPublicationToUser(publication, authorName, userId, callback);
    });
};

/**
 * Creates a publication if and only if the current user is an administrator on the tenant or users are allowed to
 * create their own publications.
 *
 * @param  {String}         tenantAlias             The tenant alias
 * @param  {String[]}       sourceIds               An array of source identifiers
 * @param  {Publication}    publication             The publication to create
 * @param  {Function}       callback                Standard callback method
 * @param  {Object}         callback.err            Standard error object
 * @param  {Object}         callback.publication    The ingested publication
 * @param  {String}         callback.result         The result of the ingestion process. This will be one of `PublicationsConstants.ingestionResult` and will indicate whether the publication has been created, updated or ignored
 */
var createPublication = module.exports.createPublication = function(tenantAlias, sourceIds, publication, callback) {
    // Sanitize the sources
    sourceIds = _.compact(sourceIds);

    var error;
    var validator = _getValidatorForPublication(publication);
    if (validator.hasErrors()) {
        error = validator.getFirstError();
    } else if (publication.embargoDate !== undefined || publication.underEmbargo !== undefined) {
        error = {'code': 400, 'msg': 'Embargoes cannot be set for new publications'};
    }

    if (error) {
        log().error({'code': error.code, 'err': error.msg}, 'Error while creating new publication');
        return callback(error);
    }

    // Sanitize the funders, if any
    if (publication && publication.funders) {
        publication.funders = _sanitizeFundersCollection(publication.funders);
    }

    // Set the embargo defaults
    publication.underEmbargo = true;
    publication.embargoDate = null;

    // Ingest the publication
    IngesterAPI.ingestPublication(tenantAlias, publication, sourceIds, function(err, publication, result) {
        if (err) {
            log().error({'err': err, 'tenantAlias': tenantAlias, 'publication': publication}, 'An error occurred while ingesting the publication');
            return callback(err);
        }

        return callback(null, publication, result);
    });
};

var _getValidatorForPublication = function(publication) {
    var validator = new Validator();
    validator.check(null, {'code': 400, 'msg': 'Missing or invalid publication'}).isObject(publication);
    if (publication) {
        validator.check(publication.displayName, {'code': 400, 'msg': 'Missing or invalid displayName'}).isShortString();
        validator.check(publication.authors, {'code': 400, 'msg': 'Missing authors'}).notEmpty();
        validator.check(null, {'code': 400, 'msg': 'Missing authors'}).isArray(publication.authors);
        validator.check(publication.journalName, {'code': 400, 'msg': 'Missing or invalid journalName'}).isShortString();
        validator.check(publication.publisher, {'code': 400, 'msg': 'Missing or invalid publisher'}).isShortString();
        validator.check(publication.date, {'code': 400, 'msg': 'Missing or invalid date'}).isNumeric();
        validator.check(publication.contactEmail, {'code': 400, 'msg': 'Missing or invalid contactEmail'}).isEmail();
        validator.check(publication.publicationType, {'code': 400, 'msg': 'Missing or invalid publicationType'}).isShortString();
        validator.check(publication.useCambridgeAddendum, {'code': 400, 'msg': 'Missing or invalid useCambridgeAddendum'}).isShortString();

        if (publication.institution) {
            validator.check(publication.institution, {'code': 400, 'msg': 'Invalid institution'}).isShortString();
        }

        if (publication.department) {
            validator.check(publication.department, {'code': 400, 'msg': 'Invalid department'}).isShortString();
        }

        if (publication.acceptanceDate !== null) {
            validator.check(publication.acceptanceDate, {'code': 400, 'msg': 'Invalid acceptanceDate'}).isNumeric();
        }
    }
    return validator;
};

/**
 * Links an OAE user to a publication. The authorname that is used in the set should be provided.
 * This does not necessarily have to be an exact match as some disambiguiation will be attempted.
 *
 * @param  {Context}    ctx             Standard context object containing the current user and the current tenant
 * @param  {String}     publicationId   The publication to link the user to
 * @param  {String}     authorName      The name of the user as its stored in the external system/on the publication
 * @param  {String}     userId          The OAE user ID to link
 * @param  {Function}   callback        Standard callback function
 */
var linkPublicationToUser = module.exports.linkPublicationToUser = function(ctx, publicationId, authorName, userId, callback) {
    if (!ctx.user()) {
        return callback({'code': 401, 'msg': 'Only authorized users are allowed to create publications'});
    }

    if (!ctx.user().isAdmin(ctx.tenant().alias) && ctx.user().id !== userId) {
        return callback({'code': 401, 'msg': 'You can only link your own user account to a publication'});
    }

    IngesterAPI.linkPublicationToUser(publicationId, authorName, userId, callback);
};

/**
 * Links an OAE user to a publication. The authorname that is used in the set should be provided.
 * This does not necessarily have to be an exact match as some disambiguiation will be attempted.
 *
 * @param  {Publication}    publication         The publication to link the user to
 * @param  {String}         authorName          The name of the user as its stored in the external system/on the publication
 * @param  {String}         userId              The OAE user ID to link
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        Standard error object, if any
 * @param  {String}         callback.result     Result of the link operation. One of `PublicationsConstants.linkResult`
 * @api private
 */
var _linkPublicationToUser = function(publication, authorName, userId, callback) {
    // Ensure that is user is not already in the author set
    var isInAuthorSet = _.contains(publication.authors, userId);
    if (isInAuthorSet) {
        return callback(null, PublicationsConstants.linkResult.PRESENT);
    }

    var plainTextAuthors = _.filter(publication.authors, function(author) {
        return (typeof author === 'string' && !AuthzUtil.isUserId(author));
    });

    // Find the best match
    var index = PublicationsUtil.findAuthorInSet(authorName, publication.authors, 0.85);
    if (index === -1) {
        log().warn({'publication': publication, 'authorName': authorName, 'userId': userId}, 'Could not find the provided author in the set of authors linked to the publication, not linking');
        return callback(null, PublicationsConstants.linkResult.NOTFOUND);
    }
    var storedAuthorName = publication.authors[index];

    log().info({'publication': publication, 'authorName': authorName, 'storedAuthorName': storedAuthorName, 'userId': userId}, 'Linking publication to a user');
    PublicationsDAO.linkPublicationToUser(publication, storedAuthorName, userId, function(err) {
        if (err) {
            return callback(err);
        }

        return callback(null, PublicationsConstants.linkResult.LINKED);
    });
};

/**
 * Updates a publication
 *
 * @param  {Context}        ctx                     Standard context object containing the current user and the current tenant
 * @param  {String}         publicationId           The publication ID (e.g p:cam:a1C2Hg5Qc1)
 * @param  {Object}         opts                    Object containing the updated publication fields
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Standard error object, if any
 * @param  {Publication}    callback.publication    The updated publication
 * @param  {String}         callback.result         The resul t of the ingestion process. This will be one of `PublicationsConstants.ingestionResult` and will indicate whether the publication has been created, updated or ignored
 */
var updatePublication = module.exports.updatePublication = function(ctx, publicationId, opts, callback) {

    // Check if valid parameters have been provided
    var validator = new PublicationsValidator();
    validator.check(publicationId, {'code': 400, 'msg': 'Missing or invalid publicationId'}).isPublicationId();

    var updates = _.keys(opts);
    validator.check(null, {'code': 400, 'msg': 'Missing or invalid changes'}).isObject(opts);
    validator.check(updates.length, {'code': 400, 'msg': 'Missing or invalid changes'}).min(1);
    _.each(opts, function(update) {
        validator.check(update, {'code': 400, 'msg': 'Missing or invalid changes'}).notNull();
    });

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Check if the user is allowed to edit the publication
    canManage(ctx, publicationId, function(err, canManage, publication) {
        if (err) {
            return callback(err);
        } else if (!canManage) {
            return callback({'code': 401, 'msg': 'You are not allowed to manage this piece of content'});
        }

        // Update the publication
        PublicationsDAO.updatePublication(publicationId, opts.publication, function(err, publication) {
            if (err) {
                log().error({'code': err.code, 'msg': err.msg, 'publicationId': publicationId}, 'Error while updating publication');
                return callback(err);
            }

            return callback(null, publication, PublicationsConstants.ingestionResult.UPDATED);
        });
    });
};

/**
 * Gets a publication by its ID
 *
 * @param  {Context}        ctx                     The current execution context
 * @param  {String}         publicationId           The ID of the publication to retrieve
 * @param  {Function}       callback                Standard callback method
 * @param  {Object}         callback.err            Standard error object
 * @param  {Publication}    callback.publication    The retrieved publication
 */
var getPublication = module.exports.getPublication = function(ctx, publicationId, callback) {
    var validator = new Validator();
    _validatePublicationId(validator, publicationId);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    PublicationsDAO.getPublication(publicationId, function(err, publication) {
        if (err) {
            return callback(err);
        }

        // Add the user profile to the publication
        _augmentPublications(ctx, [publication], function(err, publications) {
            if (err) {
                return callback(err);
            }

            return callback(null, publications[0]);
        });
    });
};

/**
 * Retrieves a set of publications for a user who created the publication
 *
 * @param  {Context}        ctx                     Standard context object containing the current user and the current tenant
 * @param  {String}         userId                  The OAE user id for whom the publications should be retrieved
 * @param  {String}         start                   The publication ordering token from which to start fetching publications (see `nextToken` in callback params)
 * @param  {Number}         limit                   The amount of publications that should be retrieved
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Standard error object, if any
 * @param  {Publication[]}  callback.publications   The publications for that user. If there are any OAE users in the co-author list, it will list their OAE profile. Otherwise, the plain-text author string will be provided
 * @param  {String}         callback.nextToken      The value to provide in the `start` parameter to get the next set of results
 */
var getPublicationsByCreator = module.exports.getPublicationsByCreator = function(ctx, userId, start, limit, callback) {
    var validator = new Validator();
    validator.check(userId, {'code': 400, 'msg': 'Missing or invalid userId'}).isUserId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    limit = OaeUtil.getNumberParam(limit, 25, 1);
    PublicationsDAO.getPublicationsByCreator(userId, start, limit, function(err, publications, nextToken) {
        if (err) {
            return callback(err);
        }

        if (publications.length === 0) {
            return callback(null, [], null);
        }

        _augmentPublications(ctx, publications, function(err, publications) {
            if (err) {
                return callback(err);
            }

            return callback(null, publications, nextToken);
        });
    });
};

/**
 * Retrieves a set of publications for a user who has been tagged as an author
 *
 * @param  {Context}        ctx                     Standard context object containing the current user and the current tenant
 * @param  {String}         userId                  The OAE user id for whom the publications should be retrieved
 * @param  {String}         start                   The publication ordering token from which to start fetching publications (see `nextToken` in callback params)
 * @param  {Number}         limit                   The amount of publications that should be retrieved
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Standard error object, if any
 * @param  {Publication[]}  callback.publications   The publications for that user. If there are any OAE users in the co-author list, it will list their OAE profile. Otherwise, the plain-text author string will be provided
 * @param  {String}         callback.nextToken      The value to provide in the `start` parameter to get the next set of results
 */
var getPublicationsForUser = module.exports.getPublicationsForUser = function(ctx, userId, start, limit, callback) {
    var validator = new Validator();
    validator.check(userId, {'code': 400, 'msg': 'Missing or invalid userId'}).isUserId();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    limit = OaeUtil.getNumberParam(limit, 25, 1);
    PublicationsDAO.getPublicationsForUser(userId, start, limit, function(err, publications, nextToken) {
        if (err) {
            return callback(err);
        }

        if (publications.length === 0) {
            return callback(null, [], null);
        }

        _augmentPublications(ctx, publications, function(err, publications) {
            if (err) {
                return callback(err);
            }

            return callback(null, publications, nextToken);
        });
    });
};

/**
 * Check whether or not the current user can manage a publication
 *
 * @param  {Context}        ctx                     Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         publicationID           The id of the publication object we want to check
 * @param  {Function}       callback                Standard callback function takes arguments `err`, `canManage`, and `content`
 * @param  {Object}         callback.err            Error object containing the error message
 * @param  {Boolean}        callback.canManage      Whether or not the user can manage the content
 */
var canManage = module.exports.canManage = function(ctx, publicationId, callback) {
    var validator = new PublicationsValidator();
    validator.check(publicationId, {'code': 400, 'msg': 'A content id must be provided'}).isPublicationId();
    validator.check(null, {'code': 401, 'msg': 'You have to be logged in to be able to manage content'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    PublicationsDAO.getPublication(publicationId, function(err, publication) {
        if (err) {
            if (err.code === 401) {
                return callback(null, false);
            } else {
                return callback(err);
            }
        }

        return callback(null, _canManage(ctx, publication), publication);
    });
};

//////////////////////////
//  INTERNAL FUNCTIONS  //
//////////////////////////

/**
 * Adds the user profiles, permissions, content profiles and decorators to the provided publications
 *
 * @param  {RestContext}        ctx                     The current execution context
 * @param  {Publication[]}      publications            The publications which need to be augemented with the augmentations
 * @param  {Function}           callback                Standard callback function
 * @param  {Object}             callback.err            Error object containing the error message
 * @param  {Publication[]}      callback.publications   The augmented publications
 * @api private
 */
var _augmentPublications = function(ctx, publications, callback) {
    var augmentations = [
        _augmentPublicationsWithUserProfiles,
        _augmentPublicationsWithPermissions,
        _augmentPublicationsWithContentProfiles,
        _augmentPublicationsWithDecorators
    ];

    var applyNextAugmentation = function(err, publications) {
        if (err) {
            return callback(err);
        } else if (augmentations.length) {
            augmentations.shift()(ctx, publications, applyNextAugmentation);
        } else {
            callback(null, publications);
        }
    };

    applyNextAugmentation(null, publications);
};

/**
 * Adds the content profiles to the publications
 *
 * @param  {RestContext}        ctx                     The current execution context
 * @param  {Publication[]}      publications            The publications which need to be augemented with the content profiles
 * @param  {Function}           callback                Standard callback function
 * @param  {Object}             callback.err            Error object containing the error message
 * @param  {Publication[]}      callback.publications   The augmented publications
 * @api private
 */
var _augmentPublicationsWithContentProfiles = function(ctx, publications, callback) {

    // Fetch al the content ID's
    var contentIds = [];
    _.each(publications, function(publication) {
        if (publication.linkedContentId) {
            if (!publication.underEmbargo || (publication.permissions.isGlobalAdmin || publication.permissions.isAdmin || publication.permissions.isSubmitter || publication.permissions.isAuthor)) {
                contentIds.push(publication.linkedContentId);
            } else {
                // Hide the linked content id from the public
                delete publication.linkedContentId;
            }
        }
    });

    // Get the content item profiles
    ContentDAO.getMultipleContentItems(contentIds, null, function(err, contentObjs) {
        if (err) {
            return callback(err);
        }

        // Add the content profiles to the publication profile
        _.each(contentObjs, function(contentObj) {
            ContentUtil.augmentContent(ctx, contentObj);
        });

        _.each(publications, function(publication) {
            var contentObj = _.find(contentObjs, function(contentObj) { return contentObj.id === publication.linkedContentId; } );
            publication.linkedContent = contentObj;
        });

        return callback(null, publications);
    });
};

/**
 * Replaces any user IDs in the set of authors with their full OAE profile
 *
 * @param  {RestContext}        ctx                     The current execution context
 * @param  {Publication[]}      publications            A set of publications
 * @param  {Function}           callback                Standard callback method
 * @param  {Object}             callback.err            Standard error object
 * @param  {Publication[]}      callback.publications   The augmented publications
 * @api private
 */
var _augmentPublicationsWithUserProfiles = function(ctx, publications, callback) {
    // Get the users who co-authored some of these publications
    var userIds = [];
    _.each(publications, function(publication) {
        userIds = userIds.concat(publication.authors);
    });

    userIds = _.chain(userIds).uniq().compact().filter(function(userId) {
        return AuthzUtil.isUserId(userId);
    }).value();

    PrincipalsUtil.getPrincipals(ctx, userIds, function(err, principals) {
        if (err) {
            return callback(err);
        }

        _.each(publications, function(publication) {
            publication.authors = _.map(publication.authors, function(authorId) {
                var principal = _.find(principals, function(principal, principalId) { return principalId === authorId; });
                return principal || authorId;
            });
        });

        return callback(null, publications);
    });
};

/**
 * Decorates a collection of publications
 *
 * @param  {Context}        ctx                     Standard context object, representing the currently logged in user and its tenant
 * @param  {Publication[]}  publications            Collection of publications to decorate
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Error object containing the error object and the error message
 * @param  {Publication[]}  callback.publications   Collection of decorated publications
 * @api private
 */
var _augmentPublicationsWithDecorators = function(ctx, publications, callback) {

    // Keep track of how many listeners still need to return
    var numDecorators = _.keys(publicationsProfileDecorators).length;
    if (numDecorators === 0) {
        log().error({'err': err}, 'Error when invoking a publication decorator');
        return callback(null, publications);
    }

    /*!
     * Complete one iteration of the listeners loop. Will invoke the method callback when each listener is completed
     */
    var _finishDecorator = function() {
        numDecorators--;
        if (numDecorators === 0) {
            return callback(null, publications);
        }
    };

    // When a publication is created, we want to run some decorators
    _.each(publicationsProfileDecorators, function(decorator, namespace) {
        decorator(ctx, publications, function(err, publications) {
            if (err) {
                log().error({'err': err, 'namespace': namespace}, 'Error when invoking a publication decorator');
                return callback(err);
            }

            return _finishDecorator();
        });
    });
};

/**
 * Adds the user permissions to the publications
 *
 * @param  {Context}        ctx                     Standard context object, representing the currently logged in user and its tenant
 * @param  {Publication[]}  publications            Collection of publications to decorate
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            Error object containing the error object and the error message
 * @param  {Publication[]}  callback.publications   Collection of decorated publications
 */
var _augmentPublicationsWithPermissions = function(ctx, publications, callback) {
    _.each(publications, function(publication) {
        if (!ctx.user()) {
            publication.permissions = {
                'isAdmin': false,
                'isGlobalAdmin': false,
                'isSubmitter': false,
                'isAuthor': false
            };
        } else {
            publication.permissions = {
                'isAdmin': ctx.user().isAdmin(publication.tenantAlias),
                'isGlobalAdmin': ctx.user().isGlobalAdmin(),
                'isSubmitter': (ctx.user().id === publication.createdBy),
                'isAuthor': _isAuthor(ctx, publication)
            };
        }
    });
    return callback(null, publications);
};

/**
 * Internal function that checks whether or not the current user can manage a piece of content. This function assumes that
 * the piece of content passed in actually exists
 *
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {Content}        publication         Object representing the publication we want to check
 * @return {Boolean}                            Whether or not the user is allowed to manage the content
 * @api private
 */
var _canManage = function(ctx, publication) {
    if (!ctx.user()) {
        return false;
    }

    // Check if the current user is a global admin
    if (ctx.user().isGlobalAdmin()) {
        return true;
    }

    // Check if the current user is the author OR the user is the admin of one of the authors
    for (var i=0; i<publication.authors.length; i++) {
        if (publication.authors[i] === ctx.user().id || _isUserAdmin(ctx.user(), publication.authors[0])) {
            return true;
        }
    }

    return false;
};

/**
 * Returns whether or not a user is an author of a publication
 *
 * @param  {Context}        ctx                 Standard context object, representing the currently logged in user and its tenant
 * @param  {Content}        publication         Object representing the publication we want to check
 * @api private
 */
var _isAuthor = function(ctx, publication) {
    return _.some(publication.authors, function(author) {
        return typeof author !== 'string' && AuthzUtil.isUserId(author.id) && ctx.user().id === author.id;
    });
};

/**
 * Check if the current user is an admin of the author's tenant
 *
 * @param  {User}           currentUser         Standard context object, representing the currently logged in user and its tenant
 * @param  {String}         author              The author of the publication
 * @return {Boolean}                            Whether the current user is an admin or not
 * @api private
 */
var _isUserAdmin = function(currentUser, author) {
    if (AuthzUtil.isUserId(author)) {
        var tenantAlias = AuthzUtil.getPrincipalFromId(author).tenantAlias;
        return currentUser.isAdmin(tenantAlias);
    }
    return false;
};

/**
 * Sanitizes a collection of funders
 *
 * @param  {String}     funders     A collection of funders
 * @return {String[]}               A sanitzed collection of funders
 * @api private
 */
var _sanitizeFundersCollection = function(funders) {
    return _.chain(funders).map(function(funder) { return funder.trim(); }).compact().value();
};

/**
 * Because publication ID's aren't tied to a tenant we can't use the typical resource ID validator.
 * This method will validate the given publication ID with the other available methods on the validator object.
 *
 * @param  {Validator}  validator       A validator instance
 * @param  {String}     publicationId   The publication ID to validate
 * @api private
 */
var _validatePublicationId = function(validator, publicationId) {
    validator.check(publicationId, {'code': 400, 'msg': 'Missing publicationId'}).notEmpty();
    if (publicationId) {
        validator.check(publicationId[0], {'code': 400, 'msg': 'Malformed publicationId'}).is('p');
    }
};
